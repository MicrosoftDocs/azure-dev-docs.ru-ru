---
title: Преимущества перехода на Java 11
titleSuffix: Azure
description: Сводный документ, предназначенный для тех, кто оценивает преимущества перехода с Java 8 на Java 11.
author: dsgrieve
manager: maverbur
tags: java
ms.topic: article
ms.date: 11/19/2019
ms.author: dagrieve
ms.custom: devx-track-java
ms.openlocfilehash: b5c1ebe2a73a9f51811118c7190e607e9387ae42
ms.sourcegitcommit: 44016b81a15b1625c464e6a7b2bfb55938df20b6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/14/2020
ms.locfileid: "86379808"
---
# <a name="reasons-to-move-to-java-11"></a>Преимущества перехода на Java 11

Нет сомнений, что переходить Java 11 *нужно*. Вопрос в том, *когда* это лучше сделать. В ближайшие несколько лет поддержка Java 8 прекратится, а значит всем пользователям нужно будет перейти на Java 11. Мы уверены, что переход на Java 11 дает весомые преимущества, и рекомендуем всем разработчикам выполнить его как можно скорее.

После выхода Java 8 было добавлено много новых функций и улучшений. В API внесены существенные дополнения и изменения, а также улучшены такие характеристики, как скорость запуска, производительность и потребление памяти.

## <a name="transitioning-to-java-11"></a>Переход на Java 11

Переход на Java 11 можно выполнять поэтапно. Для работы с Java 11 вам *не нужно* использовать в коде специальные модули Java. Java 11 можно использовать для запуска кода, который был разработан и скомпилирован в JDK 8.
Но при этом могут возникать некоторые проблемы, которые преимущественно связаны с устаревшими API, загрузчиками классов и отражениями.

Группа разработки на Java корпорации Майкрософт имеет инструкции по [переходу с Java 8 на Java 11](./transition-from-java-8-to-java-11.md). [Java Platform, Standard Edition Oracle JDK 9 Migration Guide](https://docs.oracle.com/javase/9/migrate/toc.htm) (Руководство по миграции Standard Edition Oracle JDK 9 для платформы Java) или [The State of the Module System: Compatibility and Migration](http://openjdk.java.net/projects/jigsaw/spec/sotms/#compatibility--migration) (Состояние модульной системы: совместимости и миграция) и другие полезные руководства. 

## <a name="high-level-changes-between-java-8-and-11"></a>Обобщенное описание отличий между Java 8 и 11

В этом разделе перечислены не все изменения, внесенные в версии Java 9 \[[1](#ref1)\], 10 \[[2](#ref2)\] и 11 \[[3](#ref3)\]. Выделены лишь те из них, которые заметно влияют на эффективность, диагностику и производительность.

### <a name="modules-4"></a>Модули \[[4](#ref4)\]

Модули устраняют проблемы с конфигурацией и инкапсуляцией, которые трудно отслеживать в крупномасштабных приложениях на основе *classpath*. *Модуль* — это самоописывающая коллекция классов и интерфейсов Java со всеми связанными ресурсами.

Модули позволяют настраивать конфигурации среды выполнения, которые содержат только необходимые для приложения компоненты. Это помогает сократить потребление памяти, позволяя приложению использовать статическое связывание с [jlink](https://docs.oracle.com/en/java/javase/11/tools/jlink.html) в пользовательской среде выполнения для развертывания. Сниженное потребление памяти особенно полезно при использовании архитектуры микрослужб.

На внутреннем уровне виртуальная машина Java может применять модули для повышения эффективности загрузки классов. Благодаря этому среда выполнения будет меньше, легче и быстрее. Методы оптимизации, которые виртуальная машина Java использует для повышения производительности, могут оказаться более эффективными, так как модули кодируют компоненты, требуемые для класса.

Модули помогают программистам обеспечить строгую инкапсуляцию, так как требуют явного объявления экспортируемых модулем пакетов и необходимых компонентов, а также ограничивают отражающий доступ.
Такой уровень инкапсуляции делает приложение более надежным и простым в обслуживании.

В приложении можно как и прежде использовать *classpath*. При этом вам не нужно переходить на использование модулей работы с Java 11.

### <a name="profiling-and-diagnostics"></a>Профилирование и диагностика

#### <a name="java-flight-recorder-5"></a>Java Flight Recorder \[[5](#ref5)\]

Java Flight Recorder собирает данные диагностики и профилирования из запущенного приложения Java. Java Flight Recorder практически не влияет на работу приложения Java. Собранные данные потом можно проанализировать с помощью Java Mission Control или других средств. В Java 8 Java Flight Recorder и Java Mission Control предоставлялись на коммерческой основе, а в Java 11 они включены как компоненты с открытым кодом.

#### <a name="java-mission-control-6"></a>Java Mission Control \[[6](#ref6)\]

Java Mission Control обеспечивает графическое отображение данных, собранных средством Java Flight Recorder, и предоставляется в виде компонента с открытым кодом для Java.
11. Кроме предоставления общих сведений о работающем приложении, Java Mission Control позволяет пользователю детализировать данные. Java Flight Recorder и Java Mission Control можно использовать для диагностики проблем, возникающих во время выполнения, включая утечки памяти, затраты на сборку мусора, горячие методы, узкие места и блокирующие операции ввода-вывода.

#### <a name="unified-logging-7"></a>Централизованное ведение журналов \[[7](#ref7)\]

В Java 11 организована централизованная система ведения журналов для всех компонентов виртуальной машины Java.
Эта система позволяет пользователю выбирать компоненты и уровни детализации для регистрации. Такое детализированное ведение журналов полезно при анализе причин сбоев виртуальной машины Java и диагностики проблем с производительностью в рабочей среде.

#### <a name="low-overhead-heap-profiling-8"></a>Профилирование кучи с низкими издержками \[[8](#ref8)\]

В виртуальную машину Java добавлен новый API, который предназначен для выборки выделений памяти в куче Java. Эта выборка создает низкую нагрузку и ее можно не отключать. Хотя выделение кучи можно отслеживать с помощью Java Flight Recorder, используемый метод выборки работает только для выделений. Кроме того, эта реализация может упускать выделения памяти. При этом выборка кучи в Java 11 предоставляет сведения как об активных, так и о неработающих объектах.

Поставщики средств наблюдения за производительностью приложений уже применяют эту новую функцию, и инженерная группа Java оценивает возможность объединить ее со средствами мониторинга производительности Azure.

#### <a name="stackwalker-9"></a>StackWalker \[[9](#ref9)\]

Получение моментального снимка стека в текущем потоке будет очень полезным при ведении журналов. Основная проблема заключается в том, чтобы выбрать объем трассировки стека для записи в журнал, а также принять решение о записи трассировки стека. Например, вам нужно отслеживать трассировку стека только для определенного исключения в одном методе. Класс StackWalker (добавлен в Java 9) предоставляет моментальный снимок стека и несколько методов, которые позволяют программисту контролировать использование трассировки стека.

### <a name="garbage-collection-10"></a>Сборка мусора \[[10](#ref10)\]

В Java 11 доступны следующие сборщики мусора: Serial, Parallel, Garbage-First и Epsilon. По умолчанию в Java 11 используется сборщик мусора G1GC (Garbage First Garbage Collector).

Остальные здесь упоминаются для полноты информации. Сборщик мусора ZGC (Z Garbage Collector) нацелен на параллельное выполнение с низкой задержкой — по возможности не более 10 мс. ZGC используется в Java 11 в качестве экспериментальной функции. Сборщик мусора Shenandoah рассчитан на краткую приостановку, которой он добивается за счет выполнения большего количества сборок мусора параллельно с запущенной программой Java.
Shenandoah предоставляется в качестве экспериментальной функции в Java 12, но существуют реализации с обратной совместимостью с Java 11. Доступен также сборщик CMS (Concurrent Mark and Sweep), но, начиная с версии Java 9, он объявлен нерекомендуемым.

В виртуальной машине Java по умолчанию назначается оптимальный сборщик мусора для усредненного сценария использования. Эти и другие параметры по умолчанию для сборки мусора иногда приходится изменять, чтобы добиться оптимальной пропускной способности или задержки в соответствии с требованиями приложения.
Для правильной настройки сборщика мусора нужно хорошо разбираться в принципах его работы. В этом вам может помочь [группа инженеров Microsoft Java](mailto:javaplatformgroup@microsoft.com).

#### <a name="g1gc"></a>G1GC

По умолчанию в Java 11 используется сборщик мусора G1 (G1 Garbage Collector). Задача G1GC — найти баланс между задержкой и пропускной способностью. Сборщик мусора G1 пытается достичь высокой пропускной способности, с высокой вероятностью обеспечивая заданное значение приостановки. G1GC старается избегать полных сборок мусора, выполняя их как \'резервный вариант, когда параллельные сборки не успевают восстанавливать память. При полной сборке мусора используется такое же количество параллельных рабочих потоков, что и при сборки молодого и смешанного мусора.

#### <a name="parallel-gc"></a>Сборщик мусора Parallel

Сборщик Parallel используется по умолчанию в Java 8. Сборщик мусора Parallel нацелен на обеспечение высокой пропускной способности при использовании нескольких потоков для ускорения сборки.

#### <a name="epsilon-11"></a>Epsilon \[[11](#ref11)\]

Сборщик мусора Epsilon обрабатывает выделения, но не освобождает память. Когда куча будет исчерпана, виртуальная машина Java завершит работу.
Epsilon удобно использовать для служб с коротким сроком жизни и приложений, которым гарантированно не требуется сборка мусора.

#### <a name="improvements-for-docker-containers-12"></a>Улучшения в контейнерах Docker \[[12](#ref12)\]

До версии Java 10 в виртуальной машине Java не учитывались ограничения памяти и ЦП, заданные для контейнера. Например, в Java 8 виртуальная машина Java по умолчанию ограничивала размер кучи на уровне 1/4 от общего объема физической памяти базового узла. Начиная с Java 10, в виртуальной машине Java учитываются ограничения, заданные для групп управления контейнерами (cgroup), при установке ограничений памяти и ЦП (см. примечание ниже).
Например, максимальный размер кучи по умолчанию составляет 1/4 от ограничения памяти для контейнера (500 МБ при использовании -m2G).

Также добавлены новые параметры виртуальной машины Java. Они позволяют пользователям контейнеров Docker контролировать объем системной памяти, который будет использоваться для кучи Java.

Эта возможность включена по умолчанию, но доступна только на платформах под управлением Linux.

> [!NOTE]
> Большая часть работы по поддержке cgroup направлена на обеспечение обратной совместимости в Java 8, начиная с версии jdk8u191. Мы не гарантируем, что последующие улучшения будут доступны в версии 8.

#### <a name="multi-release-jar-files-13"></a>JAR-файлы с несколькими выпусками \[[13](#ref13)\]

В Java 11 можно создать JAR-файл, который содержит несколько версий файлов классов, предназначенных для конкретных выпусков Java. Такие JAR-файлы позволяют разработчикам библиотек поддерживать несколько версий Java без необходимости предоставлять несколько версий JAR-файлов. Для потребителей этих библиотек такие JAR-файлы решают проблему подбора правильных JAR-файлов для каждой целевой версии среды выполнения.

## <a name="miscellaneous-performance-improvements"></a>Разные улучшения производительности

Следующие изменения оказывают прямое влияние на производительность виртуальной машины Java.

-   **JEP 197: сегментированный кэш кода** \[[14](#ref14)\]. Кэш кода разделен на отдельные сегменты. Такая сегментация позволяет управлять объемом памяти, используемой виртуальной машиной Java, ускоряет сканирование скомпилированных методов, значительно снижает фрагментацию кэша кода и повышает производительность.

-   **JEP 254: компактные строки** \[[15](#ref15)\]. Изменено внутреннее представление строки. В зависимости от кодировки этого символа, вместо двух байтов на символ, используется один или два байта на символ. Так как большинство строк содержат символы кодировки ISO-8859-1/Latin-1, это изменение вдвое сокращает пространство, необходимое для хранения строк.

-   **JEP 310: совместное использование данных класса приложения** \[[16](#ref16)\]. Совместное использование данных класса ускоряет запуск, позволяя сопоставлять заархивированные классы с памятью во время выполнения, а также расширяет возможность совместного использования данных класса, позволяя размещать классы приложений в архив Common Data Service. Если несколько виртуальных машин Java совместно используют один и тот же файл архива, потребление памяти и общее время отклика системы снижаются.

-   **JEP 312: локальное подтверждение в потоке** \[[17](#ref17)\]. Это позволяет выполнять обратный вызов в потоках без создания глобальной точки сохранения виртуальной машины, помогая снизить задержку для виртуальной машины за счет снижения количества глобальных точек сохранения.

-   **Отложенное выделение потоков компилятора** \[[18](#ref18)\]. В режиме многоуровневой компиляции виртуальная машина запускает большое количество потоков компилятора.
    Этот режим используется по умолчанию в системах с большим количеством процессоров. Такие потоки создаются независимо от объема доступной памяти или количества запросов компиляции. Потоки потребляют память, даже когда бездействуют (что происходит почти все время), что приводит к неэффективному использованию ресурсов. Для решения этой проблемы реализация изменена так, чтобы при запуске открывался только один поток компилятора каждого типа. Запуск дополнительных потоков и завершение работы неиспользуемых потоков осуществляется динамически. 

Следующие изменения в основных библиотеках влияют на производительность нового или измененного кода.

-   **JEP 193: дескрипторы переменных** \[[19](#ref19)\]. Определены стандартные средства для вызова эквивалентов разных операций java.util.concurrent.atomic и sun.misc.Unsafe над полями объектов и элементами массивов, стандартного набора операций ограждения для управления порядком использования памяти, а также стандартных операций границ достижимости, которые обеспечивают строгую достижимость упоминаемого объекта.

-   **JEP 269: удобные фабричные методы для коллекций** \[[20](#ref20)\]. Определены API-интерфейсы библиотеки, которые упрощают создание экземпляров коллекций и сопоставлений с небольшим количеством элементов. Эти статические фабричные методы в интерфейсах коллекции создают компактный и неизменяемый экземпляр коллекции. Такие экземпляры по своей сути являются более эффективными. API создают коллекции, которые хранятся в компактном виде и не имеют класс-оболочку.

-   **JEP 285: указания Spin-Wait** \[[21](#ref21)\]. Предоставлен API, который позволяет Java выдавать подсказки о системах среды выполнения в рамках цикла с временными задержками. Некоторые аппаратные платформы могут использовать информацию от программного обеспечения о том, что поток находится в состоянии активного ожидания.

-   **JEP 321: HTTP-клиент (стандартный)** \[[22](#ref22)\]. Предоставлен новый API клиента HTTP, который реализует HTTP/2 и WebSocket и может заменить устаревший API HttpURLConnection.

## <a name="references"></a>Ссылки

<a id="ref1">\[1\]</a> Oracle Corporation, \"Заметки о выпуске Java Development Kit 9,\" (в сети). Доступно: https://www.oracle.com/technetwork/java/javase/9u-relnotes-3704429.html.
(Проверено: 13 ноября 2019 г.).

<a id="ref2">\[2\]</a> Oracle Corporation, \"Заметки о выпуске Java Development Kit 10,\" (в сети). Доступно: https://www.oracle.com/technetwork/java/javase/10u-relnotes-4108739.html.
(Проверено: 13 ноября 2019 г.).

<a id="ref3">\[3\]</a> Oracle Corporation, \"Заметки о выпуске Java Development Kit 11,\" (в сети). Доступно: https://www.oracle.com/technetwork/java/javase/11u-relnotes-5093844.html.
(Проверено: 13 ноября 2019 г.).

<a id="ref4">\[4\]</a> Oracle Corporation, \"Проект Jigsaw,\" 22 сентября, 
2017. (в сети). Доступно: http://openjdk.java.net/projects/jigsaw/.
(Проверено: 13 ноября 2019 г.).

<a id="ref5">\[5\]</a> Oracle Corporation, \"JEP 328: Flight Recorder,\" 9 сентября 2018 г. (в сети). Доступно: http://openjdk.java.net/jeps/328. (Проверено: 13 ноября 2019 г.).

<a id="ref6">\[6\]</a> Oracle Corporation, \"Mission Control,\" 25 апреля 2019 г. (в сети). Доступно: https://wiki.openjdk.java.net/display/jmc/Main. (Проверено: 13 ноября 2019 г.).

<a id="ref7">\[7\]</a> Oracle Corporation, \"JEP 158: Централизованное ведение журналов виртуальной машины Java,\" 14 февраля 2019 г. (в сети). Доступно: http://openjdk.java.net/jeps/158.
(Проверено: 13 ноября 2019 г.).

<a id="ref8">\[8\]</a> Oracle Corporation, \"JEP 331: Профилирование кучи с низкими издержками ,\" 5 сентября 2018 г. (в сети). Доступно: http://openjdk.java.net/jeps/331. (Проверено: 13 ноября 2019 г.).

<a id="ref9">\[9\]</a> Oracle Corporation, \"JEP 259: API прохода стека,\" 18 июля 2017 г. (в сети).
Доступно: http://openjdk.java.net/jeps/259. (Проверено: 13 ноября 2019 г.).

<a id="ref10">\[10\]</a> Oracle Corporation, \"JEP 248: G1 становится сборщиком мусора по умолчанию,\" 12 сентября 2017 г. (в сети). Доступно: http://openjdk.java.net/jeps/248. (Проверено: 13 ноября 2019 г.).

<a id="ref11">\[11\]</a> Oracle Corporation, \"JEP 318: Epsilon: холостой сборщик мусора,\" 24 сентября 2018 г.
(в сети). Доступно: http://openjdk.java.net/jeps/318. (Проверено: 13 ноября 2019 г.).

<a id="ref12">\[12\]</a> Oracle Corporation, \"JDK-8146115: Улучшение обнаружения контейнеров Docker и использования конфигурации ресурсов,\" 16 сентября 2019 г.
(в сети). Доступно: https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8146115.
(Проверено: 13 ноября 2019 г.).

<a id="ref13">\[13\]</a> Oracle Corporation, \"JEP 238: JAR-файлы с несколькими выпусками, \"22 июня 2017 г. (в сети). Доступно: http://openjdk.java.net/jeps/238. (Проверено: 13 ноября 2019 г.).

<a id="ref14">\[14\]</a> Oracle Corporation, \"JEP 197: сегментированный кэш кода,\" 28 апреля 2017 г. (в сети).
Доступно: http://openjdk.java.net/jeps/197. (Проверено: 13 ноября 2019 г.).

<a id="ref15">\[15\]</a> Oracle Corporation, \"JEP 254: компактные строки,\" 18 мая 2019 г. (в сети). Доступно: http://openjdk.java.net/jeps/254.
(Проверено: 13 ноября 2019 г.).

<a id="ref16">\[16\]</a> Oracle Corporation, \"JEP 310: совместное использование данных класса приложения,\" August 17, 2018. (в сети). Доступно: https://openjdk.java.net/jeps/310. (Проверено: 13 ноября 2019 г.).

<a id="ref17">\[17\]</a> Oracle Corporation, \"JEP 312: локальное подтверждение в потоке,\" 21 августа 2019 г.
(в сети). Доступно: https://openjdk.java.net/jeps/312. (Проверено: 13 ноября 2019 г.).

<a id="ref18">\[18\]</a> Oracle Corporation, \"JDK-8198756: отложенное выделение потоков компилятора,\" 29 октября 2018 г. (в сети). Доступно: https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8198756.
(Проверено: 13 ноября 2019 г.).

<a id="ref19">\[19\]</a> Oracle Corporation, \"JEP 193: дескрипторы переменных,\" 17 августа 2017 г. (в сети). Доступно: https://openjdk.java.net/jeps/193. (Проверено: 13 ноября 2019 г.).

<a id="ref20">\[20\]</a> Oracle Corporation, \"JEP 269: удобные фабричные методы для коллекций,\" 26 июня 2017 г. (в сети). Доступно: https://openjdk.java.net/jeps/269.
(Проверено: 13 ноября 2019 г.).

<a id="ref21">\[21\]</a> Oracle Corporation, \"JEP 285: Указания цикла ожидания,\" 20 августа 2017 г. (в сети). Доступно: https://openjdk.java.net/jeps/285. (Проверено: 13 ноября 2019 г.).

<a id="ref22">\[22\]</a> Oracle Corporation, \"JEP 321: HTTP-клиент (стандартный),\" 27 сентября 2018 г. (в сети).
Доступно: https://openjdk.java.net/jeps/321. (Проверено: 13 ноября 2019 г.).
