---
title: Пошаговое руководство. Часть 2. Аутентификация приложений Python в службах Azure
description: Обсуждение различных требований к проверке подлинности и связанных проблем на примере сценария, а также анализ того, как решить эти проблемы при использовании интегрированной проверки подлинности Azure.
ms.date: 08/24/2020
ms.topic: conceptual
ms.custom: devx-track-python
ms.openlocfilehash: 2e3755f7049fd091c05cd2aca5ddf8276cebff95
ms.sourcegitcommit: 29b161c450479e5d264473482d31e8d3bf29c7c0
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2020
ms.locfileid: "91764427"
---
# <a name="part-2-authentication-needs-in-the-scenario"></a>Часть 2. Требования к проверке подлинности в сценарии

[Предыдущая часть. Вводная информация и справка](walkthrough-tutorial-authentication-01.md)

В этом примере сценария основное приложение имеет следующие требования к проверке подлинности:

- проверка подлинности с использованием Azure Key Vault для получения доступа к хранимому ключу API стороннего разработчика;
- проверка подлинности с помощью стороннего API и использованием ключа API;
- проверка подлинности с помощью Хранилища очередей Azure и использованием необходимых учетных данных для учетной записи хранения.

В рамках этих трех требований приложение должно управлять тремя наборами учетных данных: двумя для ресурсов Azure (Key Vault и Хранилище очередей) и одним для внешнего ресурса (сторонний API).

Как отмечалось ранее, вы можете безопасно управлять всеми учетными данными в Key Vault, кроме учетных данных, требуемых для самого хранилища Key Vault. После проверки подлинности с помощью Key Vault приложение может получить любые другие ключи во время выполнения для проверки подлинности с помощью таких служб, как Хранилище очередей.

Но при таком подходе все равно требуется, чтобы приложение отдельно управляло учетными данными для Key Vault. Как же тогда можно безопасно управлять учетными данными и работать с ними как при локальной разработке, так и при рабочем развертывании в облаке?

Частичное решение заключается в хранении ключа в переменной среды на стороне сервера (т. е. с помощью параметра приложения в Службе приложений Azure и Функциях Azure), что хотя бы предотвращает возможность получения доступа к ключу для системы управления версиями. Но для запуска кода на рабочей станции разработчика эту переменную среды необходимо реплицировать локально, что может привести к раскрытию учетных данных и (или) их случайного включения в систему управления версиями. Эту проблему можно частично решить, реализовав специальные процедуры в версии кода для разработки, но это усложняет процесс разработки.

К счастью, встроенная проверка подлинности с помощью Azure Active Directory (Azure AD) полностью исключает приложения из процесса обработки учетных данных Azure.

## <a name="integrated-authentication-with-managed-identity"></a>Интегрированная проверка подлинности с управляемым удостоверением

Многие службы Azure, такие как служба хранилища и Key Vault, интегрируются с Azure Active Directory (Azure AD). При этом, когда вы выполняете проверку подлинности приложения в Azure AD с помощью [управляемого удостоверения](/azure/active-directory/managed-identities-azure-resources/overview), этот процесс автоматически охватывает другие подключенные ресурсы. Авторизация для удостоверения обрабатывается с помощью [управления доступом на основе ролей (RBAC)](/azure/role-based-access-control/role-assignments-steps) и иногда через другие политики доступа.

Такая интеграция означает, что вам не нужно управлять учетными данными, связанными с Azure, в коде приложения, и эти учетные данные никогда не будут отображаться на рабочих станциях разработчиков или в системе управления версиями. Кроме того, любая обработка ключей для сторонних API и служб осуществляется полностью во время выполнения, что обеспечивает защиту этих ключей.

Управляемое удостоверение работает с приложениями, развернутыми в Azure. Для локальной разработки можно создать отдельный субъект-службу, который будет использоваться в качестве удостоверения приложения при локальном запуске. Этот субъект-служба становится доступным для библиотек Azure с помощью переменных среды, как описано в разделе [Настройка аутентификации](configure-local-development-environment.md#configure-authentication) статьи "Настройка локальной среды разработки Python для Azure". Вы также назначаете разрешения роли для этого субъекта-службы вместе с управляемым удостоверением, используемым в облаке.

После выполнения этих действий для локального субъекта-службы один и тот же код будет работать как локально, так и в облаке, отвечая за проверку подлинности приложения с использованием ресурсов Azure. Эти сведения обсуждаются отдельно в статье [Как аутентифицировать и авторизовать приложения Python в Azure](azure-sdk-authenticate.md), но вы можете ознакомиться с краткими инструкциями ниже:

1. Создайте в коде объект `DefaultAzureCredential`, который автоматически использует управляемое удостоверение при работе в Azure и отдельный субъект-службу для локального выполнения.

1. Используйте эти учетные данные при создании соответствующего объекта клиента для ресурса, к которому необходимо получить доступ (Key Vault, Хранилище очередей и т. д.).

1. Проверка подлинности выполнятся при вызове операции через объект клиента, который создает вызов REST API к ресурсу.

1. Если удостоверение приложения является допустимым, в Azure также проверяется, авторизовано ли это удостоверение для конкретной операции.

В оставшейся части этого руководства показаны все детали процесса в контексте примера сценария и приведен соответствующий пример кода.

В скрипте подготовки примера все ресурсы создаются в группе ресурсов с именем `auth-scenario-rg`. Эта группа создается с помощью команды [`az group create`](/cli/azure/group#az-group-create) Azure CLI.

> [!div class="nextstepaction"]
> [Часть 3. Пример реализации стороннего API >>>](walkthrough-tutorial-authentication-03.md)
